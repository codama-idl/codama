{% extends "layout.njk" %}

{% block main %}

"""Extensions to the Borsh spec for Solana-specific types."""
from typing import Any,cast

import borsh_construct as borsh
from construct import (
    Adapter,
    Construct,
    GreedyBytes,
    PaddedString,
    Padded,
    Padding,
    Prefixed,
    Renamed,
    Switch,
    IfThenElse
)

U64Bytes = Prefixed(borsh.U64, GreedyBytes)
U8Bytes = Prefixed(borsh.U8, GreedyBytes)

class _String64(Adapter):
    def __init__(self) -> None:
        super().__init__(U64Bytes)  # type: ignore

    def _decode(self, obj: bytes, context, path) -> str:
        return obj.decode("utf8")

    def _encode(self, obj: str, context, path) -> bytes:
        return bytes(obj, "utf8")
class _String8(Adapter):
    def __init__(self) -> None:
        super().__init__(U8Bytes)  # type: ignore

    def _decode(self, obj: bytes, context, path) -> str:
        return obj.decode("utf8")

    def _encode(self, obj: str, context, path) -> bytes:
        return bytes(obj, "utf8")

String64=_String64()
String8=_String8()

class HiddenPrefixAdapter(Adapter):
    prefix = None
    def __init__(self,padding,subcon: Construct):
        self.prefix = padding
        prefix_struct = borsh.CStruct(
            "prefix"/borsh.U8[len(padding)],
            "data"/subcon,
        )
        super().__init__(prefix_struct)

    def _decode(self, obj, context, path) -> Any:
        return obj["data"]

    def _encode(self, obj, context, path) -> dict:
        return { "prefix": self.prefix, "data": obj}

class HiddenSuffixAdapter(Adapter):
    suffix = None
    def __init__(self,padding,subcon: Construct):
        self.suffix = padding
        suffix_struct = borsh.CStruct(
            "suffix"/borsh.U8[len(padding)],
            "data"/subcon,
        )
        super().__init__(suffix_struct)

    def _decode(self, obj, context, path) -> Any:
        return obj["data"]

    def _encode(self, obj, context, path) -> dict:
        return { "data": obj, "suffix": self.suffix}

class OptionU32(Adapter):
    _discriminator_key = "discriminator"
    _value_key = "value"

    def __init__(self, subcon: Construct) -> None:
        option_struct = borsh.CStruct(
            self._discriminator_key / borsh.U32,
            self._value_key
            / IfThenElse(
                lambda this: this[self._discriminator_key] == 0,
                Padding(subcon.sizeof()),
                subcon,
            ),
        )
        super().__init__(option_struct)  # type: ignore

    def _decode(self, obj, context, path) -> Any:
        discriminator = obj[self._discriminator_key]
        return None if discriminator == 0 else obj[self._value_key]

    def _encode(self, obj, context, path) -> dict:
        discriminator = 0 if obj is None else 1
        return {self._discriminator_key: discriminator, self._value_key: obj}

class RemainderOption(Adapter):
    _discriminator_key = "discriminator"
    _value_key = "value"

    def __init__(self, subcon: Construct) -> None:
        option_struct = borsh.CStruct(
            self._discriminator_key / borsh.U32,
            self._value_key
            / IfThenElse(
                lambda this: this[self._discriminator_key] == 0,
                Padding(subcon.sizeof()),
                subcon,
            ),
        )
        super().__init__(option_struct)  # type: ignore

    def _decode(self, obj, context, path) -> Any:
        discriminator = obj[self._discriminator_key]
        return None if discriminator == 0 else obj[self._value_key]

    def _encode(self, obj, context, path) -> dict:
        discriminator = 0 if obj is None else 1
        return {self._discriminator_key: discriminator, self._value_key: obj}


class EnumForCodegenU32(Adapter):
    _index_key = "index"
    _value_key = "value"

    def __init__(self, *variants: "Renamed[borsh.CStruct, borsh.CStruct]") -> None:
        """Init enum."""
        switch_cases: dict[int, "Renamed[borsh.CStruct, borsh.CStruct]"] = {}
        variant_name_to_index: dict[str, int] = {}
        index_to_variant_name: dict[int, str] = {}
        for idx, parser in enumerate(variants):
            switch_cases[idx] = parser
            name = cast(str, parser.name)
            variant_name_to_index[name] = idx
            index_to_variant_name[idx] = name
        enum_struct = borsh.CStruct(
            self._index_key /borsh.U32,
            self._value_key
            / Switch(lambda this: this.index, cast(dict[int, Construct], switch_cases)),
        )
        super().__init__(enum_struct)  # type: ignore
        self.variant_name_to_index = variant_name_to_index
        self.index_to_variant_name = index_to_variant_name

    def _decode(self, obj: borsh.CStruct, context, path) -> dict[str, Any]:
        index = obj.index
        variant_name = self.index_to_variant_name[index]
        return {variant_name: obj.value}

    def _encode(self, obj: dict[str, Any], context, path) -> dict[str, Any]:
        variant_name = list(obj.keys())[0]
        index = self.variant_name_to_index[variant_name]
        return {self._index_key: index, self._value_key: obj[variant_name]}

FixedSizeString=PaddedString
FixedSizeBytes=Padded
{% endblock %}
