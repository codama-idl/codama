'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''


"""Extensions to the Borsh spec for Solana-specific types."""
from dataclasses import asdict
from keyword import kwlist
from typing import Any, Dict, Type, TypeVar, cast

import borsh_construct as borsh
from construct import (
    Adapter,
    Bytes,
    Construct,
    Container,
    IfThenElse,
    Padding,
    Renamed,
    Switch,
    GreedyBytesï¼Œ
    Prefixed
)
from solders import pubkey

U64Bytes = Prefixed(borsh.U64, GreedyBytes)
U8Bytes = Prefixed(borsh.U8, GreedyBytes)

class _String64(Adapter):
    def __init__(self) -> None:
        super().__init__(U64Bytes)  # type: ignore

    def _decode(self, obj: bytes, context, path) -> str:
        return obj.decode("utf8")

    def _encode(self, obj: str, context, path) -> bytes:
        return bytes(obj, "utf8")
class _String8(Adapter):
    def __init__(self) -> None:
        super().__init__(U8Bytes)  # type: ignore

    def _decode(self, obj: bytes, context, path) -> str:
        return obj.decode("utf8")

    def _encode(self, obj: str, context, path) -> bytes:
        return bytes(obj, "utf8")

String64=_String64()
String8=_String8()

class HiddenPrefixAdapter(Adapter):
    prefix = None
    def __init__(self,padding,subcon: Construct):
        self.prefix = padding
        prefix_struct = CStruct(
            "prefix"/borsh.U8[len(padding)],
            "data"/subcon,
        )
        super().__init__(prefix_struct)

    def _decode(self, obj, context, path) -> Any:
        return obj["data"]

    def _encode(self, obj, context, path) -> dict:
        return { "prefix": self.prefix, "data": obj}

class HiddenSuffixAdapter(Adapter):
    suffix = None
    def __init__(self,padding,subcon: Construct):
        self.suffix = padding
        suffix_struct = CStruct(
            "suffix"/borsh.U8[len(padding)],
            "data"/subcon,
        )
        super().__init__(suffix_struct)

    def _decode(self, obj, context, path) -> Any:
        return obj["data"]

    def _encode(self, obj, context, path) -> dict:
        return { "data": obj, "suffix": self.suffix}


class EnumForCodegenU32(Adapter):
    _index_key = "index"
    _value_key = "value"

    def __init__(self, *variants: "Renamed[CStruct, CStruct]") -> None:
        """Init enum."""
        switch_cases: dict[int, "Renamed[CStruct, CStruct]"] = {}
        variant_name_to_index: dict[str, int] = {}
        index_to_variant_name: dict[int, str] = {}
        for idx, parser in enumerate(variants):
            switch_cases[idx] = parser
            name = cast(str, parser.name)
            variant_name_to_index[name] = idx
            index_to_variant_name[idx] = name
        enum_struct = CStruct(
            self._index_key /borsh.U32,
            self._value_key
            / Switch(lambda this: this.index, cast(dict[int, borsh.Construct], switch_cases)),
        )
        super().__init__(enum_struct)  # type: ignore
        self.variant_name_to_index = variant_name_to_index
        self.index_to_variant_name = index_to_variant_name

    def _decode(self, obj: borsh.Struct, context, path) -> dict[str, Any]:
        index = obj.index
        variant_name = self.index_to_variant_name[index]
        return {variant_name: obj.value}

    def _encode(self, obj: dict[str, Any], context, path) -> dict[str, Any]:
        variant_name = list(obj.keys())[0]
        index = self.variant_name_to_index[variant_name]
        return {self._index_key: index, self._value_key: obj[variant_name]}
