'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;

AboveJSONValue = tuple[int]
AboveValue = tuple[int]

class AboveJSON(typing.TypedDict):
    kind: typing.Literal["Above"]
    value: AboveJSONValue


@dataclass
class Above:
    discriminator: typing.ClassVar = 0
    value : AboveValue
    def to_json(self) -> AboveJSON:
        return AboveJSON(
            kind="Above",
            value = (self.value[0],)
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Above": { "item_0":self.value[0] }
        }



BelowJSONValue = tuple[int]
BelowValue = tuple[int]

class BelowJSON(typing.TypedDict):
    kind: typing.Literal["Below"]
    value: BelowJSONValue


@dataclass
class Below:
    discriminator: typing.ClassVar = 1
    value : BelowValue
    def to_json(self) -> BelowJSON:
        return BelowJSON(
            kind="Below",
            value = (self.value[0],)
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Below": { "item_0":self.value[0] }
        }



EqualJSONValue = tuple[int]
EqualValue = tuple[int]

class EqualJSON(typing.TypedDict):
    kind: typing.Literal["Equal"]
    value: EqualJSONValue


@dataclass
class Equal:
    discriminator: typing.ClassVar = 2
    value : EqualValue
    def to_json(self) -> EqualJSON:
        return EqualJSON(
            kind="Equal",
            value = (self.value[0],)
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Equal": { "item_0":self.value[0] }
        }



RangJSONValue = tuple[int,int]
RangValue = tuple[int,int]

class RangJSON(typing.TypedDict):
    kind: typing.Literal["Rang"]
    value: RangJSONValue


@dataclass
class Rang:
    discriminator: typing.ClassVar = 3
    value : RangValue
    def to_json(self) -> RangJSON:
        return RangJSON(
            kind="Rang",
            value = (self.value[0],self.value[1],)
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Rang": { "item_0":self.value[0],"item_1":self.value[1] }
        }





TransferAmountRuleKind = typing.Union[
    Above,
    Below,
    Equal,
    Rang,
]
TransferAmountRuleJSON = typing.Union[
    AboveJSON,
    BelowJSON,
    EqualJSON,
    RangJSON,
]

def from_decoded(obj: dict) -> TransferAmountRuleKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Above" in obj:
      val = obj["Above"]
      return Above((
      val["item_0"],
      ))
    if "Below" in obj:
      val = obj["Below"]
      return Below((
      val["item_0"],
      ))
    if "Equal" in obj:
      val = obj["Equal"]
      return Equal((
      val["item_0"],
      ))
    if "Rang" in obj:
      val = obj["Rang"]
      return Rang((
      val["item_0"],val["item_1"],
      ))
    raise ValueError("Invalid enum object")

def from_json(obj: TransferAmountRuleJSON) -> TransferAmountRuleKind:
    if obj["kind"] == "Above":
        aboveJSONValue = typing.cast(AboveJSONValue, obj["value"])
        return Above(
        (aboveJSONValue[0],)
        )

    if obj["kind"] == "Below":
        belowJSONValue = typing.cast(BelowJSONValue, obj["value"])
        return Below(
        (belowJSONValue[0],)
        )

    if obj["kind"] == "Equal":
        equalJSONValue = typing.cast(EqualJSONValue, obj["value"])
        return Equal(
        (equalJSONValue[0],)
        )

    if obj["kind"] == "Rang":
        rangJSONValue = typing.cast(RangJSONValue, obj["value"])
        return Rang(
        (rangJSONValue[0],rangJSONValue[1],)
        )

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Above" / borsh.CStruct("item_0" / borsh.U64,),
"Below" / borsh.CStruct("item_0" / borsh.U64,),
"Equal" / borsh.CStruct("item_0" / borsh.U64,),
"Rang" / borsh.CStruct("item_0" / borsh.U64,"item_1" / borsh.U64,),
)
