import { Docs } from '@codama/nodes';
import { BaseFragment } from '@codama/renderers-core';

import { ImportMap } from './importMap';
import { RenderScope } from './options';

export type Fragment = BaseFragment & Readonly<{ imports: ImportMap }>;

function isFragment(value: unknown): value is Fragment {
    return typeof value === 'object' && value !== null && 'content' in value && 'imports' in value;
}

export function fragment(template: TemplateStringsArray, ...items: unknown[]): Fragment {
    return createFragmentTemplate(template, items, isFragment, mergeFragments);
}

export function mergeFragments(fragments: (Fragment | undefined)[], mergeContent: (contents: string[]) => string) {
    const filteredFragments = fragments.filter((f): f is Fragment => typeof f !== 'undefined');
    return Object.freeze({
        content: mergeContent(filteredFragments.map(f => f.content)),
        imports: new ImportMap().mergeWith(...filteredFragments.map(f => f.imports)),
    });
}

export function mergeFragmentImports(fragment: Fragment, importMaps: ImportMap[]): Fragment {
    return Object.freeze({
        ...fragment,
        imports: new ImportMap().mergeWith(fragment.imports, ...importMaps),
    });
}

export function addFragmentImports(fragment: Fragment, imports: string[]): Fragment {
    return Object.freeze({
        ...fragment,
        imports: new ImportMap().mergeWith(fragment.imports).add(imports),
    });
}

export function addFragmentImportAlias(fragment: Fragment, importName: string, alias: string): Fragment {
    return Object.freeze({
        ...fragment,
        imports: new ImportMap().mergeWith(fragment.imports).addAlias(importName, alias),
    });
}

export function getDocblockFragment(lines: Docs, withLineJump = false, internal = false): Fragment {
    const prefix = internal ? '//!' : '///';
    const lineJump = withLineJump ? '\n' : '';
    if (lines.length === 0) return fragment``;
    const prefixedLines = lines.map(line => (line ? `${prefix} ${line}` : prefix));
    return fragment`${prefixedLines.join('\n')}${lineJump}`;
}

export function getPageFragment(page: Fragment, scope: Pick<RenderScope, 'dependencyMap'>): Fragment {
    const docs = [
        'This code was AUTOGENERATED using the Codama library.',
        'Please DO NOT EDIT THIS FILE, instead use visitors',
        'to add features, then rerun Codama to update it.',
        '',
        '<https://github.com/codama-idl/codama>',
    ];
    const header = getDocblockFragment(docs, false, true);
    const imports = page.imports.isEmpty() ? undefined : fragment`${page.imports.toString(scope.dependencyMap)}`;
    return mergeFragments([header, imports, page], cs => cs.join('\n\n'));
}

// TODO: Will be part of renderers-core soon.
function createFragmentTemplate<TFragment extends BaseFragment>(
    template: TemplateStringsArray,
    items: unknown[],
    isFragment: (value: unknown) => value is TFragment,
    mergeFragments: (fragments: TFragment[], mergeContent: (contents: string[]) => string) => TFragment,
): TFragment {
    const fragments = items.filter(isFragment);
    const zippedItems = items.map((item, i) => {
        const itemPrefix = template[i];
        if (typeof item === 'undefined') return itemPrefix;
        if (isFragment(item)) return itemPrefix + item.content;
        return itemPrefix + String(item);
    });
    return mergeFragments(fragments, () => zippedItems.join('') + template[template.length - 1]);
}
